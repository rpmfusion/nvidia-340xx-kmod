diff --git a/kernel/conftest.Kbuild b/kernel/conftest.Kbuild
index 69643cd..1778e87 100644
--- a/kernel/conftest.Kbuild
+++ b/kernel/conftest.Kbuild
@@ -87,6 +87,7 @@ NV_CONFTEST_TYPE_COMPILE_TESTS += drm_driver_prime_flag_present
 
 NV_CONFTEST_TYPE_COMPILE_TESTS += mm_has_mmap_lock
 NV_CONFTEST_TYPE_COMPILE_TESTS += drm_gem_object_vmap_has_map_arg
+NV_CONFTEST_TYPE_COMPILE_TESTS += drm_device_has_pdev
 NV_CONFTEST_TYPE_COMPILE_TESTS += drm_mode_object_find_has_file_priv_arg
 NV_CONFTEST_TYPE_COMPILE_TESTS += drm_prime_pages_to_sg_has_drm_device_arg
 NV_CONFTEST_TYPE_COMPILE_TESTS += drm_gem_object_has_resv
diff --git a/kernel/conftest.sh b/kernel/conftest.sh
index f2e4c91..a21c5bd 100755
--- a/kernel/conftest.sh
+++ b/kernel/conftest.sh
@@ -4654,6 +4654,29 @@ compile_test() {
 
             compile_check_conftest "$CODE" "NV_DRM_GEM_OBJECT_VMAP_HAS_MAP_ARG" "" "types"
         ;;
+
+        drm_device_has_pdev)
+            #
+            # Determine if the 'drm_device' structure has a 'pdev' field.
+            #
+            # Removed by commit b347e04452ff ("drm: Remove pdev field from
+            # struct drm_device") in v5.14-rc1.
+            #
+            CODE="
+            #if defined(NV_DRM_DRMP_H_PRESENT)
+            #include <drm/drmP.h>
+            #endif
+
+            #if defined(NV_DRM_DRM_DEVICE_H_PRESENT)
+            #include <drm/drm_device.h>
+            #endif
+
+            int conftest_drm_device_has_pdev(void) {
+                return offsetof(struct drm_device, pdev);
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_DEVICE_HAS_PDEV" "" "types"
+        ;;
     esac
 }
 
diff --git a/kernel/nv-drm.c b/kernel/nv-drm.c
index 9e0b9c5..45cab9b 100644
--- a/kernel/nv-drm.c
+++ b/kernel/nv-drm.c
@@ -70,20 +70,35 @@ struct nv_gem_object {
     struct page **pages;
 };
 
+#if !defined(NV_DRM_DEVICE_HAS_PDEV)
+#include <drm/drm_legacy.h>
+struct nv_drm_extra_priv_data {
+    struct pci_dev *pdev;
+    struct drm_agp_head *agp;
+};
+#endif
+
 static int nv_drm_load(
     struct drm_device *dev,
     unsigned long flags
 )
 {
     nv_linux_state_t *nvl;
+#if !defined(NV_DRM_DEVICE_HAS_PDEV)
+    struct nv_drm_extra_priv_data *extra = dev->dev_private;
+#endif
 
     for (nvl = nv_linux_devices; nvl != NULL; nvl = nvl->next)
     {
-        if (nvl->dev == dev->pdev)
-        {
-            nvl->drm = dev;
-            return 0;
-        }
+#if defined(NV_DRM_DEVICE_HAS_PDEV)
+       if (nvl->dev == dev->pdev)
+#else
+       if (nvl->dev == extra->pdev)
+#endif
+       {
+           nvl->drm = dev;
+           return 0;
+       }
     }
 
     return -ENODEV;
@@ -100,11 +115,18 @@ static int __nv_drm_unload(
 )
 {
     nv_linux_state_t *nvl;
+#if !defined(NV_DRM_DEVICE_HAS_PDEV)
+    struct nv_drm_extra_priv_data *extra = dev->dev_private;
+#endif
 
     for (nvl = nv_linux_devices; nvl != NULL; nvl = nvl->next)
     {
-        if (nvl->dev == dev->pdev)
-        {
+#if defined(NV_DRM_DEVICE_HAS_PDEV)
+       if (nvl->dev == dev->pdev)
+#else
+       if (nvl->dev == extra->pdev)
+#endif
+       {
             BUG_ON(nvl->drm != dev);
             nvl->drm = NULL;
             return 0;
@@ -347,6 +369,7 @@ static void nv_drm_register_drm_device(const nv_gpu_info_t *gpu_info)
 {
     struct nv_drm_device *nv_dev = NULL;
     struct drm_device *dev = NULL;
+    struct nv_drm_extra_priv_data *extra;
     struct pci_dev *pdev = gpu_info->os_dev_ptr;
 
     DRM_DEBUG(
@@ -380,7 +403,14 @@ static void nv_drm_register_drm_device(const nv_gpu_info_t *gpu_info)
 
     dev->dev_private = nv_dev;
     nv_dev->dev = dev;
+
+#if defined(NV_DRM_DEVICE_HAS_PDEV)
     dev->pdev = pdev;
+#else
+    extra = kzalloc(sizeof(*extra), GFP_KERNEL);
+    extra->pdev = pdev;
+    dev->dev_private = extra;
+#endif
 
     /* Register DRM device to DRM sub-system */
 
diff --git a/kernel/os-interface.c b/kernel/os-interface.c
index 0c0dc05..452609d 100644
--- a/kernel/os-interface.c
+++ b/kernel/os-interface.c
@@ -549,7 +549,7 @@ RM_STATUS NV_API_CALL os_delay(NvU32 MilliSeconds)
         // the requested timeout has expired, loop until less
         // than a jiffie of the desired delay remains.
         //
-        current->state = TASK_INTERRUPTIBLE;
+        set_current_state(TASK_INTERRUPTIBLE);
         do
         {
             schedule_timeout(jiffies);
